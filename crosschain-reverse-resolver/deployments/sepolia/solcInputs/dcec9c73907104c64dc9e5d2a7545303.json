{
  "language": "Solidity",
  "sources": {
    "@ensdomains/ens-contracts/contracts/registry/ENS.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/IMulticallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IMulticallable {\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/Multicallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IMulticallable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nabstract contract Multicallable is IMulticallable, ERC165 {\n    function _multicall(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) internal returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            if (nodehash != bytes32(0)) {\n                bytes32 txNamehash = bytes32(data[i][4:36]);\n                require(\n                    txNamehash == nodehash,\n                    \"multicall: All records must have a matching namehash\"\n                );\n            }\n            (bool success, bytes memory result) = address(this).delegatecall(\n                data[i]\n            );\n            require(success);\n            results[i] = result;\n        }\n        return results;\n    }\n\n    // This function provides an extra security check when called\n    // from priviledged contracts (such as EthRegistrarController)\n    // that can set records on behalf of the node owners\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results) {\n        return _multicall(nodehash, data);\n    }\n\n    function multicall(\n        bytes[] calldata data\n    ) public override returns (bytes[] memory results) {\n        return _multicall(bytes32(0), data);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IMulticallable).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/INameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface INameResolver {\n    event NameChanged(bytes32 indexed node, string name);\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) external view returns (string memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface ITextResolver {\n    event TextChanged(\n        bytes32 indexed node,\n        string indexed indexedKey,\n        string key,\n        string value\n    );\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view returns (string memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IVersionableResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IVersionableResolver {\n    event VersionChanged(bytes32 indexed node, uint64 newVersion);\n\n    function recordVersions(bytes32 node) external view returns (uint64);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/reverseRegistrar/IL2ReverseRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface IL2ReverseRegistrar {\n    function setName(string memory name) external returns (bytes32);\n\n    function setNameForAddr(\n        address addr,\n        string memory name\n    ) external returns (bytes32);\n\n    function setNameForAddrWithSignature(\n        address addr,\n        string memory name,\n        uint256 inceptionDate,\n        bytes memory signature\n    ) external returns (bytes32);\n\n    function setNameForAddrWithSignatureAndOwnable(\n        address contractAddr,\n        address owner,\n        string memory name,\n        uint256 inceptionDate,\n        bytes memory signature\n    ) external returns (bytes32);\n\n    function setText(\n        string calldata key,\n        string calldata value\n    ) external returns (bytes32);\n\n    function setTextForAddr(\n        address addr,\n        string calldata key,\n        string calldata value\n    ) external returns (bytes32);\n\n    function setTextForAddrWithSignature(\n        address addr,\n        string calldata key,\n        string calldata value,\n        uint256 inceptionDate,\n        bytes memory signature\n    ) external returns (bytes32);\n\n    function setTextForAddrWithSignatureAndOwnable(\n        address contractAddr,\n        address owner,\n        string calldata key,\n        string calldata value,\n        uint256 inceptionDate,\n        bytes memory signature\n    ) external returns (bytes32);\n\n    function clearRecords(address addr) external;\n\n    function clearRecordsWithSignature(\n        address addr,\n        uint256 inceptionDate,\n        bytes memory signature\n    ) external;\n\n    function node(address addr) external view returns (bytes32);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/reverseRegistrar/L2ReverseRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"./IL2ReverseRegistrar.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../resolvers/profiles/ITextResolver.sol\";\nimport \"../resolvers/profiles/INameResolver.sol\";\nimport \"../root/Controllable.sol\";\nimport \"../resolvers/Multicallable.sol\";\n\nerror InvalidSignature();\nerror SignatureOutOfDate();\nerror Unauthorised();\nerror NotOwnerOfContract();\n\n// @note Inception date\n// The inception date is in milliseconds, and so will be divided by 1000\n// when comparing to block.timestamp. This means that the date will be\n// rounded down to the nearest second.\n\ncontract L2ReverseRegistrar is\n    Multicallable,\n    Ownable,\n    ITextResolver,\n    INameResolver,\n    IL2ReverseRegistrar\n{\n    using ECDSA for bytes32;\n    mapping(bytes32 => uint256) public lastUpdated;\n    mapping(uint64 => mapping(bytes32 => mapping(string => string))) versionable_texts;\n    mapping(uint64 => mapping(bytes32 => string)) versionable_names;\n    mapping(bytes32 => uint64) internal recordVersions;\n    event VersionChanged(bytes32 indexed node, uint64 newVersion);\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n\n    bytes32 public immutable L2ReverseNode;\n    uint256 public immutable coinType;\n\n    // This is the hex encoding of the string 'abcdefghijklmnopqrstuvwxyz'\n    // It is used as a constant to lookup the characters of the hex address\n    bytes32 constant lookup =\n        0x3031323334353637383961626364656600000000000000000000000000000000;\n\n    /**\n     * @dev Constructor\n     */\n    constructor(bytes32 _L2ReverseNode, uint256 _coinType) {\n        L2ReverseNode = _L2ReverseNode;\n        coinType = _coinType;\n    }\n\n    modifier authorised(address addr) {\n        isAuthorised(addr);\n        _;\n    }\n\n    modifier authorisedSignature(\n        bytes32 hash,\n        address addr,\n        uint256 inceptionDate,\n        bytes memory signature\n    ) {\n        isAuthorisedWithSignature(hash, addr, inceptionDate, signature);\n        _;\n    }\n\n    modifier ownerAndAuthorisedWithSignature(\n        bytes32 hash,\n        address addr,\n        address owner,\n        uint256 inceptionDate,\n        bytes memory signature\n    ) {\n        isOwnerAndAuthorisedWithSignature(\n            hash,\n            addr,\n            owner,\n            inceptionDate,\n            signature\n        );\n        _;\n    }\n\n    function isAuthorised(address addr) internal view returns (bool) {\n        if (addr != msg.sender && !ownsContract(addr, msg.sender)) {\n            revert Unauthorised();\n        }\n    }\n\n    function isAuthorisedWithSignature(\n        bytes32 hash,\n        address addr,\n        uint256 inceptionDate,\n        bytes memory signature\n    ) internal view returns (bool) {\n        bytes32 message = keccak256(\n            abi.encodePacked(hash, addr, inceptionDate, coinType)\n        ).toEthSignedMessageHash();\n        bytes32 node = _getNamehash(addr);\n\n        if (!SignatureChecker.isValidSignatureNow(addr, message, signature)) {\n            revert InvalidSignature();\n        }\n\n        if (\n            inceptionDate <= lastUpdated[node] || // must be newer than current record\n            inceptionDate / 1000 >= block.timestamp // must be in the past\n        ) {\n            revert SignatureOutOfDate();\n        }\n    }\n\n    function isOwnerAndAuthorisedWithSignature(\n        bytes32 hash,\n        address addr,\n        address owner,\n        uint256 inceptionDate,\n        bytes memory signature\n    ) internal view returns (bool) {\n        bytes32 message = keccak256(\n            abi.encodePacked(hash, addr, owner, inceptionDate, coinType)\n        ).toEthSignedMessageHash();\n        bytes32 node = _getNamehash(addr);\n\n        if (!ownsContract(addr, owner)) {\n            revert NotOwnerOfContract();\n        }\n\n        if (\n            !SignatureChecker.isValidERC1271SignatureNow(\n                owner,\n                message,\n                signature\n            )\n        ) {\n            revert InvalidSignature();\n        }\n\n        if (\n            inceptionDate <= lastUpdated[node] || // must be newer than current record\n            inceptionDate / 1000 >= block.timestamp // must be in the past\n        ) {\n            revert SignatureOutOfDate();\n        }\n    }\n\n    /**\n     * @dev Sets the name for an addr using a signature that can be verified with ERC1271.\n     * @param addr The reverse record to set\n     * @param name The name of the reverse record\n     * @param inceptionDate Date from when this signature is valid from\n     * @param signature The resolver of the reverse node\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddrWithSignature(\n        address addr,\n        string memory name,\n        uint256 inceptionDate,\n        bytes memory signature\n    )\n        public\n        override\n        authorisedSignature(\n            keccak256(\n                abi.encodePacked(\n                    IL2ReverseRegistrar.setNameForAddrWithSignature.selector,\n                    name\n                )\n            ),\n            addr,\n            inceptionDate,\n            signature\n        )\n        returns (bytes32)\n    {\n        bytes32 node = _getNamehash(addr);\n\n        _setName(node, name, inceptionDate);\n        return node;\n    }\n\n    /**\n     * @dev Sets the name for a contract that is owned by a SCW using a signature\n     * @param contractAddr The reverse node to set\n     * @param owner The owner of the contract (via Ownable)\n     * @param name The name of the reverse record\n     * @param inceptionDate Date from when this signature is valid from\n     * @param signature The signature of an address that will return true on isValidSignature for the owner\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddrWithSignatureAndOwnable(\n        address contractAddr,\n        address owner,\n        string memory name,\n        uint256 inceptionDate,\n        bytes memory signature\n    )\n        public\n        ownerAndAuthorisedWithSignature(\n            keccak256(\n                abi.encodePacked(\n                    IL2ReverseRegistrar\n                        .setNameForAddrWithSignatureAndOwnable\n                        .selector,\n                    name\n                )\n            ),\n            contractAddr,\n            owner,\n            inceptionDate,\n            signature\n        )\n        returns (bytes32)\n    {\n        bytes32 node = _getNamehash(contractAddr);\n        _setName(node, name, inceptionDate);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public override returns (bytes32) {\n        return setNameForAddr(msg.sender, name);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the addr provided account.\n     * Can be used if the addr is a contract that is owned by a SCW.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n\n    function setNameForAddr(\n        address addr,\n        string memory name\n    ) public authorised(addr) returns (bytes32) {\n        bytes32 node = _getNamehash(addr);\n        _setName(node, name, block.timestamp);\n        return node;\n    }\n\n    /**\n     * @dev Sets the name for an addr using a signature that can be verified with ERC1271.\n     * @param addr The reverse record to set\n     * @param key The key of the text record\n     * @param value The value of the text record\n     * @param inceptionDate Date from when this signature is valid from\n     * @param signature The resolver of the reverse node\n     * @return The ENS node hash of the reverse record.\n     */\n    function setTextForAddrWithSignature(\n        address addr,\n        string calldata key,\n        string calldata value,\n        uint256 inceptionDate,\n        bytes memory signature\n    )\n        public\n        override\n        authorisedSignature(\n            keccak256(\n                abi.encodePacked(\n                    IL2ReverseRegistrar.setTextForAddrWithSignature.selector,\n                    key,\n                    value\n                )\n            ),\n            addr,\n            inceptionDate,\n            signature\n        )\n        returns (bytes32)\n    {\n        bytes32 node = _getNamehash(addr);\n        _setText(node, key, value, inceptionDate);\n        return node;\n    }\n\n    /**\n     * @dev Sets the name for a contract that is owned by a SCW using a signature\n     * @param contractAddr The reverse node to set\n     * @param owner The owner of the contract (via Ownable)\n     * @param key The name of the reverse record\n     * @param value The name of the reverse record\n     * @param inceptionDate Date from when this signature is valid from\n     * @param signature The signature of an address that will return true on isValidSignature for the owner\n     * @return The ENS node hash of the reverse record.\n     */\n    function setTextForAddrWithSignatureAndOwnable(\n        address contractAddr,\n        address owner,\n        string calldata key,\n        string calldata value,\n        uint256 inceptionDate,\n        bytes memory signature\n    )\n        public\n        ownerAndAuthorisedWithSignature(\n            keccak256(\n                abi.encodePacked(\n                    IL2ReverseRegistrar\n                        .setTextForAddrWithSignatureAndOwnable\n                        .selector,\n                    key,\n                    value\n                )\n            ),\n            contractAddr,\n            owner,\n            inceptionDate,\n            signature\n        )\n        returns (bytes32)\n    {\n        bytes32 node = _getNamehash(contractAddr);\n        _setText(node, key, value, inceptionDate);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account.\n     * @param key The key for this text record.\n     * @param value The value to set for this text record.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setText(\n        string calldata key,\n        string calldata value\n    ) public override returns (bytes32) {\n        return setTextForAddr(msg.sender, key, value);\n    }\n\n    /**\n     * @dev Sets the `text(key)` record for the reverse ENS record associated with\n     * the addr provided account.\n     * @param key The key for this text record.\n     * @param value The value to set for this text record.\n     * @return The ENS node hash of the reverse record.\n     */\n\n    function setTextForAddr(\n        address addr,\n        string calldata key,\n        string calldata value\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 node = _getNamehash(addr);\n        _setText(node, key, value, block.timestamp);\n        return node;\n    }\n\n    function _setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value,\n        uint256 inceptionDate\n    ) internal {\n        versionable_texts[recordVersions[node]][node][key] = value;\n        _setLastUpdated(node, inceptionDate);\n        emit TextChanged(node, key, key, value);\n    }\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view virtual override returns (string memory) {\n        return versionable_texts[recordVersions[node]][node][key];\n    }\n\n    /**\n     * Sets the name associated with an ENS node, for reverse records.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param newName name record\n     */\n    function _setName(\n        bytes32 node,\n        string memory newName,\n        uint256 inceptionDate\n    ) internal virtual {\n        versionable_names[recordVersions[node]][node] = newName;\n        _setLastUpdated(node, inceptionDate);\n        emit NameChanged(node, newName);\n    }\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(\n        bytes32 node\n    ) external view virtual override returns (string memory) {\n        return versionable_names[recordVersions[node]][node];\n    }\n\n    /**\n     * Increments the record version associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param addr The node to update.\n     */\n    function clearRecords(address addr) public virtual authorised(addr) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(L2ReverseNode, labelHash)\n        );\n        recordVersions[reverseNode]++;\n        emit VersionChanged(reverseNode, recordVersions[reverseNode]);\n    }\n\n    /**\n     * Increments the record version associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param addr The node to update.\n     * @param signature A signature proving ownership of the node.\n     */\n    function clearRecordsWithSignature(\n        address addr,\n        uint256 inceptionDate,\n        bytes memory signature\n    )\n        public\n        virtual\n        authorisedSignature(\n            keccak256(\n                abi.encodePacked(\n                    IL2ReverseRegistrar.clearRecordsWithSignature.selector\n                )\n            ),\n            addr,\n            inceptionDate,\n            signature\n        )\n    {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(L2ReverseNode, labelHash)\n        );\n        recordVersions[reverseNode]++;\n        emit VersionChanged(reverseNode, recordVersions[reverseNode]);\n    }\n\n    /**\n     * @dev Returns the node hash for a given account's reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public view override returns (bytes32) {\n        return keccak256(abi.encodePacked(L2ReverseNode, sha3HexAddress(addr)));\n    }\n\n    function ownsContract(\n        address contractAddr,\n        address addr\n    ) internal view returns (bool) {\n        try Ownable(contractAddr).owner() returns (address owner) {\n            return owner == addr;\n        } catch {\n            return false;\n        }\n    }\n\n    function _getNamehash(address addr) internal view returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        return keccak256(abi.encodePacked(L2ReverseNode, labelHash));\n    }\n\n    function _setLastUpdated(bytes32 node, uint256 inceptionDate) internal {\n        lastUpdated[node] = inceptionDate;\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) internal pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(Multicallable) returns (bool) {\n        return\n            interfaceID == type(IL2ReverseRegistrar).interfaceId ||\n            interfaceID == type(ITextResolver).interfaceId ||\n            interfaceID == type(INameResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/root/Controllable.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Controllable is Ownable {\n    mapping(address => bool) public controllers;\n\n    event ControllerChanged(address indexed controller, bool enabled);\n\n    modifier onlyController() {\n        require(\n            controllers[msg.sender],\n            \"Controllable: Caller is not a controller\"\n        );\n        _;\n    }\n\n    function setController(address controller, bool enabled) public onlyOwner {\n        controllers[controller] = enabled;\n        emit ControllerChanged(controller, enabled);\n    }\n}\n"
    },
    "@ensdomains/evm-verifier/contracts/EVMFetcher.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IEVMVerifier } from './IEVMVerifier.sol';\nimport { EVMFetchTarget } from './EVMFetchTarget.sol';\nimport { Address } from '@openzeppelin/contracts/utils/Address.sol';\n\ninterface IEVMGateway {\n    function getStorageSlots(address addr, bytes32[] memory commands, bytes[] memory constants) external pure returns(bytes memory witness);\n}\n\nuint8 constant FLAG_DYNAMIC = 0x01;\nuint8 constant OP_CONSTANT = 0x00;\nuint8 constant OP_BACKREF = 0x20;\nuint8 constant OP_END = 0xff;\n\n/**\n * @dev A library to facilitate requesting storage data proofs from contracts, possibly on a different chain.\n *      See l1-verifier/test/TestL1.sol for example usage.\n */\nlibrary EVMFetcher {\n    uint256 constant MAX_COMMANDS = 32;\n    uint256 constant MAX_CONSTANTS = 32; // Must not be greater than 32\n\n    using Address for address;\n\n    error TooManyCommands(uint256 max);\n    error CommandTooLong();\n    error InvalidReference(uint256 value, uint256 max);\n    error OffchainLookup(address sender, string[] urls, bytes callData, bytes4 callbackFunction, bytes extraData);\n\n    struct EVMFetchRequest {\n        IEVMVerifier verifier;\n        address target;\n        bytes32[] commands;\n        uint256 operationIdx;\n        bytes[] constants;\n    }\n\n    /**\n     * @dev Creates a request to fetch the value of multiple storage slots from a contract via CCIP-Read, possibly from\n     *      another chain.\n     *      Supports dynamic length values and slot numbers derived from other retrieved values.\n     * @param verifier An instance of a verifier contract that can provide and verify the storage slot information.\n     * @param target The address of the contract to fetch storage proofs for.\n     */\n    function newFetchRequest(IEVMVerifier verifier, address target) internal pure returns (EVMFetchRequest memory) {\n        bytes32[] memory commands = new bytes32[](MAX_COMMANDS);\n        bytes[] memory constants = new bytes[](MAX_CONSTANTS);\n        assembly {\n            mstore(commands, 0) // Set current array length to 0\n            mstore(constants, 0)\n        }        \n        return EVMFetchRequest(verifier, target, commands, 0, constants);\n    }\n\n    /**\n     * @dev Starts describing a new fetch request.\n     *      Paths specify a series of hashing operations to derive the final slot ID.\n     *      See https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html for details on how Solidity\n     *      lays out storage variables.\n     * @param request The request object being operated on.\n     * @param baseSlot The base slot ID that forms the root of the path.\n     */\n    function getStatic(EVMFetchRequest memory request, uint256 baseSlot) internal pure returns (EVMFetchRequest memory) {\n        bytes32[] memory commands = request.commands;\n        uint256 commandIdx = commands.length;\n        if(commandIdx > 0 && request.operationIdx < 32) {\n            // Terminate previous command\n            _addOperation(request, OP_END);\n        }\n        assembly {\n            mstore(commands, add(commandIdx, 1)) // Increment command array length\n        }\n        if(request.commands.length > MAX_COMMANDS) {\n            revert TooManyCommands(MAX_COMMANDS);\n        }\n        request.operationIdx = 0;\n        _addOperation(request, 0);\n        _addOperation(request, _addConstant(request, abi.encode(baseSlot)));\n        return request;\n    }\n\n    /**\n     * @dev Starts describing a new fetch request.\n     *      Paths specify a series of hashing operations to derive the final slot ID.\n     *      See https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html for details on how Solidity\n     *      lays out storage variables.\n     * @param request The request object being operated on.\n     * @param baseSlot The base slot ID that forms the root of the path.\n     */\n    function getDynamic(EVMFetchRequest memory request, uint256 baseSlot) internal pure returns (EVMFetchRequest memory) {\n        bytes32[] memory commands = request.commands;\n        uint256 commandIdx = commands.length;\n        if(commandIdx > 0 && request.operationIdx < 32) {\n            // Terminate previous command\n            _addOperation(request, OP_END);\n        }\n        assembly {\n            mstore(commands, add(commandIdx, 1)) // Increment command array length\n        }\n        if(request.commands.length > MAX_COMMANDS) {\n            revert TooManyCommands(MAX_COMMANDS);\n        }\n        request.operationIdx = 0;\n        _addOperation(request, FLAG_DYNAMIC);\n        _addOperation(request, _addConstant(request, abi.encode(baseSlot)));\n        return request;\n    }\n\n    /**\n     * @dev Adds a `uint256` element to the current path.\n     * @param request The request object being operated on.\n     * @param el The element to add.\n     */\n    function element(EVMFetchRequest memory request, uint256 el) internal pure returns (EVMFetchRequest memory) {\n        if(request.operationIdx >= 32) {\n            revert CommandTooLong();\n        }\n        _addOperation(request, _addConstant(request, abi.encode(el)));\n        return request;\n    }\n\n    /**\n     * @dev Adds a `bytes32` element to the current path.\n     * @param request The request object being operated on.\n     * @param el The element to add.\n     */\n    function element(EVMFetchRequest memory request, bytes32 el) internal pure returns (EVMFetchRequest memory) {\n        if(request.operationIdx >= 32) {\n            revert CommandTooLong();\n        }\n        _addOperation(request, _addConstant(request, abi.encode(el)));\n        return request;\n    }\n\n    /**\n     * @dev Adds an `address` element to the current path.\n     * @param request The request object being operated on.\n     * @param el The element to add.\n     */\n    function element(EVMFetchRequest memory request, address el) internal pure returns (EVMFetchRequest memory) {\n        if(request.operationIdx >= 32) {\n            revert CommandTooLong();\n        }\n        _addOperation(request, _addConstant(request, abi.encode(el)));\n        return request;\n    }\n\n    /**\n     * @dev Adds a `bytes` element to the current path.\n     * @param request The request object being operated on.\n     * @param el The element to add.\n     */\n    function element(EVMFetchRequest memory request, bytes memory el) internal pure returns (EVMFetchRequest memory) {\n        if(request.operationIdx >= 32) {\n            revert CommandTooLong();\n        }\n        _addOperation(request, _addConstant(request, el));\n        return request;\n    }\n\n    /**\n     * @dev Adds a `string` element to the current path.\n     * @param request The request object being operated on.\n     * @param el The element to add.\n     */\n    function element(EVMFetchRequest memory request, string memory el) internal pure returns (EVMFetchRequest memory) {\n        if(request.operationIdx >= 32) {\n            revert CommandTooLong();\n        }\n        _addOperation(request, _addConstant(request, bytes(el)));\n        return request;\n    }\n\n    /**\n     * @dev Adds a reference to a previous fetch to the current path.\n     * @param request The request object being operated on.\n     * @param idx The index of the previous fetch request, starting at 0.\n     */\n    function ref(EVMFetchRequest memory request, uint8 idx) internal pure returns (EVMFetchRequest memory) {\n        if(request.operationIdx >= 32) {\n            revert CommandTooLong();\n        }\n        if(idx > request.commands.length || idx > 31) {\n            revert InvalidReference(idx, request.commands.length);\n        }\n        _addOperation(request, OP_BACKREF | idx);\n        return request;\n    }\n\n    /**\n     * @dev Initiates the fetch request.\n     *      Calling this function terminates execution; clients that implement CCIP-Read will make a callback to\n     *      `callback` with the results of the operation.\n     * @param callbackId A callback function selector on this contract that will be invoked via CCIP-Read with the result of the lookup.\n     *        The function must have a signature matching `(bytes[] memory values, bytes callbackData)` with a return type matching the call in which\n     *        this function was invoked. Its return data will be returned as the return value of the entire CCIP-read operation.\n     * @param callbackData Extra data to supply to the callback.\n     */\n    function fetch(EVMFetchRequest memory request, bytes4 callbackId, bytes memory callbackData) internal view {\n        if(request.commands.length > 0 && request.operationIdx < 32) {\n            // Terminate last command\n            _addOperation(request, OP_END);\n        }\n        revert OffchainLookup(\n            address(this),\n            request.verifier.gatewayURLs(),\n            abi.encodeCall(IEVMGateway.getStorageSlots, (request.target, request.commands, request.constants)),\n            EVMFetchTarget.getStorageSlotsCallback.selector,\n            abi.encode(request.verifier, request.target, request.commands, request.constants, callbackId, callbackData)\n        );\n    }\n\n    function _addConstant(EVMFetchRequest memory request, bytes memory value) private pure returns(uint8 idx) {\n        bytes[] memory constants = request.constants;\n        idx = uint8(constants.length);\n        assembly {\n            mstore(constants, add(idx, 1)) // Increment constant array length\n        }\n        constants[idx] = value;\n    }\n\n    function _addOperation(EVMFetchRequest memory request, uint8 op) private pure {\n        uint256 commandIdx = request.commands.length - 1;\n        request.commands[commandIdx] = request.commands[commandIdx] | (bytes32(bytes1(op)) >> (8 * request.operationIdx++));\n    }\n}\n"
    },
    "@ensdomains/evm-verifier/contracts/EVMFetchTarget.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IEVMVerifier } from './IEVMVerifier.sol';\nimport { Address } from '@openzeppelin/contracts/utils/Address.sol';\n\n/**\n * @dev Callback implementation for users of `EVMFetcher`. If you use `EVMFetcher`, your contract must\n *      inherit from this contract in order to handle callbacks correctly.\n */\nabstract contract EVMFetchTarget {\n    using Address for address;\n\n    error ResponseLengthMismatch(uint256 actual, uint256 expected);\n\n    /**\n     * @dev Internal callback function invoked by CCIP-Read in response to a `getStorageSlots` request.\n     */\n    function getStorageSlotsCallback(bytes calldata response, bytes calldata extradata) external {\n        bytes memory proof = abi.decode(response, (bytes));\n        (IEVMVerifier verifier, address addr, bytes32[] memory commands, bytes[] memory constants, bytes4 callback, bytes memory callbackData) =\n            abi.decode(extradata, (IEVMVerifier, address, bytes32[], bytes[], bytes4, bytes));\n        bytes[] memory values = verifier.getStorageValues(addr, commands, constants, proof);\n        if(values.length != commands.length) {\n            revert ResponseLengthMismatch(values.length, commands.length);\n        }\n        bytes memory ret = address(this).functionCall(abi.encodeWithSelector(callback, values, callbackData));\n        assembly {\n            return(add(ret, 32), mload(ret))\n        }\n    }\n}\n"
    },
    "@ensdomains/evm-verifier/contracts/EVMProofHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {RLPReader} from \"@eth-optimism/contracts-bedrock/src/libraries/rlp/RLPReader.sol\";\nimport {Bytes} from \"@eth-optimism/contracts-bedrock/src/libraries/Bytes.sol\";\nimport {SecureMerkleTrie} from \"./SecureMerkleTrie.sol\";\n\nstruct StateProof {\n    bytes[] stateTrieWitness;         // Witness proving the `storageRoot` against a state root.\n    bytes[][] storageProofs;          // An array of proofs of individual storage elements \n}\n\nuint8 constant OP_CONSTANT = 0x00;\nuint8 constant OP_BACKREF = 0x20;\nuint8 constant FLAG_DYNAMIC = 0x01;\n\nlibrary EVMProofHelper {\n    using Bytes for bytes;\n\n    error AccountNotFound(address);\n    error UnknownOpcode(uint8);\n    error InvalidSlotSize(uint256 size);\n\n    /**\n     * @notice Get the storage root for the provided merkle proof\n     * @param stateRoot The state root the witness was generated against\n     * @param target The address we are fetching a storage root for\n     * @param witness A witness proving the value of the storage root for `target`.\n     * @return The storage root retrieved from the provided state root\n     */\n    function getStorageRoot(bytes32 stateRoot, address target, bytes[] memory witness) private pure returns (bytes32) {\n        (bool exists, bytes memory encodedResolverAccount) = SecureMerkleTrie.get(\n            abi.encodePacked(target),\n            witness,\n            stateRoot\n        );\n        if(!exists) {\n            revert AccountNotFound(target);\n        }\n        RLPReader.RLPItem[] memory accountState = RLPReader.readList(encodedResolverAccount);\n        return bytes32(RLPReader.readBytes(accountState[2]));\n    }\n\n    /**\n     * @notice Prove whether the provided storage slot is part of the storageRoot\n     * @param storageRoot the storage root for the account that contains the storage slot\n     * @param slot The storage key we are fetching the value of\n     * @param witness the StorageProof struct containing the necessary proof data\n     * @return The retrieved storage proof value or 0x if the storage slot is empty\n     */\n    function getSingleStorageProof(bytes32 storageRoot, uint256 slot, bytes[] memory witness) private pure returns (bytes memory) {\n        (bool exists, bytes memory retrievedValue) = SecureMerkleTrie.get(\n            abi.encodePacked(slot),\n            witness,\n            storageRoot\n        );\n        if(!exists) {\n            // Nonexistent values are treated as zero.\n            return \"\";\n        }\n        return RLPReader.readBytes(retrievedValue);\n    }\n\n    function getFixedValue(bytes32 storageRoot, uint256 slot, bytes[] memory witness) private pure returns(bytes32) {\n        bytes memory value = getSingleStorageProof(storageRoot, slot, witness);\n        // RLP encoded storage slots are stored without leading 0 bytes.\n        // Casting to bytes32 appends trailing 0 bytes, so we have to bit shift to get the \n        // original fixed-length representation back.\n        return bytes32(value) >> (256 - 8 * value.length);\n    }\n\n    function executeOperation(bytes1 operation, bytes[] memory constants, bytes[] memory values) private pure returns(bytes memory) {\n        uint8 opcode = uint8(operation) & 0xe0;\n        uint8 operand = uint8(operation) & 0x1f;\n\n        if(opcode == OP_CONSTANT) {\n            return constants[operand];\n        } else if(opcode == OP_BACKREF) {\n            return values[operand];\n        } else {\n            revert UnknownOpcode(opcode);\n        }\n    }\n\n    function computeFirstSlot(bytes32 command, bytes[] memory constants, bytes[] memory values) private pure returns(bool isDynamic, uint256 slot) {\n        uint8 flags = uint8(command[0]);\n        isDynamic = (flags & FLAG_DYNAMIC) != 0;\n\n        bytes memory slotData = executeOperation(command[1], constants, values);\n        require(slotData.length == 32, \"First path element must be 32 bytes\");\n        slot = uint256(bytes32(slotData));\n\n        for(uint256 j = 2; j < 32 && command[j] != 0xff; j++) {\n            bytes memory index = executeOperation(command[j], constants, values);\n            slot = uint256(keccak256(abi.encodePacked(index, slot)));\n        }\n    }\n\n    function getDynamicValue(bytes32 storageRoot, uint256 slot, StateProof memory proof, uint256 proofIdx) private pure returns(bytes memory value, uint256 newProofIdx) {\n        uint256 firstValue = uint256(getFixedValue(storageRoot, slot, proof.storageProofs[proofIdx++]));\n        if(firstValue & 0x01 == 0x01) {\n            // Long value: first slot is `length * 2 + 1`, following slots are data.\n            uint256 length = (firstValue - 1) / 2;\n            value = \"\";\n            slot = uint256(keccak256(abi.encodePacked(slot)));\n            // This is horribly inefficient - O(n^2). A better approach would be to build an array of words and concatenate them\n            // all at once, but we're trying to avoid writing new library code.\n            while(length > 0) {\n                if(length < 32) {\n                    value = bytes.concat(value, getSingleStorageProof(storageRoot, slot++, proof.storageProofs[proofIdx++]).slice(0, length));\n                    length = 0;\n                } else {\n                    value = bytes.concat(value, getSingleStorageProof(storageRoot, slot++, proof.storageProofs[proofIdx++]));\n                    length -= 32;\n                }\n            }\n            return (value, proofIdx);\n        } else {\n            // Short value: least significant byte is `length * 2`, other bytes are data.\n            uint256 length = (firstValue & 0xFF) / 2;\n            return (abi.encode(firstValue).slice(0, length), proofIdx);\n        }\n    }\n\n    function getStorageValues(address target, bytes32[] memory commands, bytes[] memory constants, bytes32 stateRoot, StateProof memory proof) internal pure returns(bytes[] memory values) {\n        bytes32 storageRoot = getStorageRoot(stateRoot, target, proof.stateTrieWitness);\n        uint256 proofIdx = 0;\n        values = new bytes[](commands.length);\n        for(uint256 i = 0; i < commands.length; i++) {\n            bytes32 command = commands[i];\n            (bool isDynamic, uint256 slot) = computeFirstSlot(command, constants, values);\n            if(!isDynamic) {\n                values[i] = abi.encode(getFixedValue(storageRoot, slot, proof.storageProofs[proofIdx++]));\n                if(values[i].length > 32) {\n                    revert InvalidSlotSize(values[i].length);\n                }\n            } else {\n                (values[i], proofIdx) = getDynamicValue(storageRoot, slot, proof, proofIdx);\n            }\n        }\n    }\n}"
    },
    "@ensdomains/evm-verifier/contracts/IEVMVerifier.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IEVMVerifier {\n    function gatewayURLs() external view returns(string[] memory);\n    function getStorageValues(address target, bytes32[] memory commands, bytes[] memory constants, bytes memory proof) external view returns(bytes[] memory values);\n}\n"
    },
    "@ensdomains/evm-verifier/contracts/MerkleTrie.sol": {
      "content": "// Pulled from https://github.com/ethereum-optimism/optimism/blob/4d13f0afe8869faf7bba45d8339998525ebc5161/packages/contracts-bedrock/contracts/libraries/trie/MerkleTrie.sol\n//   as this is the last version of Optimism's Merkle Trie library that supports nonexistence proofs; support was removed\n//   in the next commit for some version.\n// Copyright 2020-2021 Optimism\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Bytes } from \"@eth-optimism/contracts-bedrock/src/libraries/Bytes.sol\";\nimport { RLPReader } from \"@eth-optimism/contracts-bedrock/src/libraries/rlp/RLPReader.sol\";\n\n\n/**\n * @title MerkleTrie\n * @notice MerkleTrie is a small library for verifying standard Ethereum Merkle-Patricia trie\n *         inclusion proofs. By default, this library assumes a hexary trie. One can change the\n *         trie radix constant to support other trie radixes.\n */\nlibrary MerkleTrie {\n    /**\n     * @notice Struct representing a node in the trie.\n     */\n    struct TrieNode {\n        bytes encoded;\n        RLPReader.RLPItem[] decoded;\n    }\n\n    /**\n     * @notice Determines the number of elements per branch node.\n     */\n    uint256 internal constant TREE_RADIX = 16;\n\n    /**\n     * @notice Branch nodes have TREE_RADIX elements and one value element.\n     */\n    uint256 internal constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\n\n    /**\n     * @notice Leaf nodes and extension nodes have two elements, a `path` and a `value`.\n     */\n    uint256 internal constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\n\n    /**\n     * @notice Prefix for even-nibbled extension node paths.\n     */\n    uint8 internal constant PREFIX_EXTENSION_EVEN = 0;\n\n    /**\n     * @notice Prefix for odd-nibbled extension node paths.\n     */\n    uint8 internal constant PREFIX_EXTENSION_ODD = 1;\n\n    /**\n     * @notice Prefix for even-nibbled leaf node paths.\n     */\n    uint8 internal constant PREFIX_LEAF_EVEN = 2;\n\n    /**\n     * @notice Prefix for odd-nibbled leaf node paths.\n     */\n    uint8 internal constant PREFIX_LEAF_ODD = 3;\n\n    /**\n     * @notice RLP representation of `NULL`.\n     */\n    bytes internal constant RLP_NULL = hex\"80\";\n\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the trie.\n     *\n     * @param _key   Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\n     *               trees, this proof is executed top-down and consists of a list of RLP-encoded\n     *               nodes that make a path down to the target node.\n     * @param _root  Known root of the Merkle trie. Used to verify that the included proof is\n     *               correctly constructed.\n     *\n     * @return Whether or not the proof is valid.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes[] memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool) {\n        (bool exists, bytes memory value) = get(_key, _proof, _root);\n        return (exists && Bytes.equal(_value, value));\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     *\n     * @param _key   Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root  Known root of the Merkle trie.\n     *\n     * @return Whether or not the key exists.\n     * @return Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes[] memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool, bytes memory) {\n        TrieNode[] memory proof = _parseProof(_proof);\n        (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(\n            proof,\n            _key,\n            _root\n        );\n\n        bool noRemainder = keyRemainder.length == 0;\n\n        require(noRemainder || isFinalNode, \"MerkleTrie: provided proof is invalid\");\n\n        bytes memory value = noRemainder ? _getNodeValue(proof[pathLength - 1]) : bytes(\"\");\n\n        return (value.length > 0, value);\n    }\n\n    /**\n     * @notice Walks through a proof using a provided key.\n     *\n     * @param _proof Inclusion proof to walk through.\n     * @param _key   Key to use for the walk.\n     * @param _root  Known root of the trie.\n     *\n     * @return Length of the final path\n     * @return Portion of the key remaining after the walk.\n     * @return Whether or not we've hit a dead end.\n     */\n    // solhint-disable-next-line code-complexity\n    function _walkNodePath(\n        TrieNode[] memory _proof,\n        bytes memory _key,\n        bytes32 _root\n    )\n        private\n        pure\n        returns (\n            uint256,\n            bytes memory,\n            bool\n        )\n    {\n        uint256 pathLength = 0;\n        bytes memory key = Bytes.toNibbles(_key);\n\n        bytes memory currentNodeID = abi.encodePacked(_root);\n        uint256 currentKeyIndex = 0;\n        uint256 currentKeyIncrement = 0;\n        TrieNode memory currentNode;\n\n        // Proof is top-down, so we start at the first element (root).\n        for (uint256 i = 0; i < _proof.length; i++) {\n            currentNode = _proof[i];\n            currentKeyIndex += currentKeyIncrement;\n\n            // Keep track of the proof elements we actually need.\n            // It's expensive to resize arrays, so this simply reduces gas costs.\n            pathLength += 1;\n\n            if (currentKeyIndex == 0) {\n                // First proof element is always the root node.\n                require(\n                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),\n                    \"MerkleTrie: invalid root hash\"\n                );\n            } else if (currentNode.encoded.length >= 32) {\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\n                require(\n                    Bytes.equal(abi.encodePacked(keccak256(currentNode.encoded)), currentNodeID),\n                    \"MerkleTrie: invalid large internal hash\"\n                );\n            } else {\n                // Nodes smaller than 32 bytes aren't hashed.\n                require(\n                    Bytes.equal(currentNode.encoded, currentNodeID),\n                    \"MerkleTrie: invalid internal node hash\"\n                );\n            }\n\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\n                if (currentKeyIndex == key.length) {\n                    // We've hit the end of the key\n                    // meaning the value should be within this branch node.\n                    break;\n                } else {\n                    // We're not at the end of the key yet.\n                    // Figure out what the next node ID should be and continue.\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\n                    RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\n                    currentNodeID = _getNodeID(nextNode);\n                    currentKeyIncrement = 1;\n                    continue;\n                }\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\n                bytes memory path = _getNodePath(currentNode);\n                uint8 prefix = uint8(path[0]);\n                uint8 offset = 2 - (prefix % 2);\n                bytes memory pathRemainder = Bytes.slice(path, offset);\n                bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\n\n                require(\n                    keyRemainder.length >= pathRemainder.length,\n                    \"MerkleTrie: invalid key length for leaf or extension node\"\n                );\n\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\n                    if (\n                        pathRemainder.length == sharedNibbleLength &&\n                        keyRemainder.length == sharedNibbleLength\n                    ) {\n                        // The key within this leaf matches our key exactly.\n                        // Increment the key index to reflect that we have no remainder.\n                        currentKeyIndex += sharedNibbleLength;\n                    }\n\n                    // We've hit a leaf node, so our next node should be NULL.\n                    currentNodeID = RLP_NULL;\n                    break;\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\n                    if (sharedNibbleLength != pathRemainder.length) {\n                        // Our extension node is not identical to the remainder.\n                        // We've hit the end of this path\n                        // updates will need to modify this extension.\n                        currentNodeID = RLP_NULL;\n                        break;\n                    } else {\n                        // Our extension shares some nibbles.\n                        // Carry on to the next node.\n                        currentNodeID = _getNodeID(currentNode.decoded[1]);\n                        currentKeyIncrement = sharedNibbleLength;\n                        continue;\n                    }\n                } else {\n                    revert(\"MerkleTrie: received a node with an unknown prefix\");\n                }\n            } else {\n                revert(\"MerkleTrie: received an unparseable node\");\n            }\n        }\n\n        return (\n            pathLength,\n            Bytes.slice(key, currentKeyIndex),\n            Bytes.equal(currentNodeID, RLP_NULL)\n        );\n    }\n\n    /**\n     * @notice Parses an array of proof elements into a new array that contains both the original\n     *         encoded element and the RLP-decoded element.\n     *\n     * @param _proof Array of proof elements to parse.\n     *\n     * @return Proof parsed into easily accessible structs.\n     */\n    function _parseProof(bytes[] memory _proof) private pure returns (TrieNode[] memory) {\n        uint256 length = _proof.length;\n        TrieNode[] memory proof = new TrieNode[](length);\n        for (uint256 i = 0; i < length; ) {\n            proof[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) });\n            unchecked {\n                ++i;\n            }\n        }\n        return proof;\n    }\n\n    /**\n     * @notice Picks out the ID for a node. Node ID is referred to as the \"hash\" within the\n     *         specification, but nodes < 32 bytes are not actually hashed.\n     *\n     * @param _node Node to pull an ID for.\n     *\n     * @return ID for the node, depending on the size of its contents.\n     */\n    function _getNodeID(RLPReader.RLPItem memory _node) private pure returns (bytes memory) {\n        return _node.length < 32 ? RLPReader.readRawBytes(_node) : RLPReader.readBytes(_node);\n    }\n\n    /**\n     * @notice Gets the path for a leaf or extension node.\n     *\n     * @param _node Node to get a path for.\n     *\n     * @return Node path, converted to an array of nibbles.\n     */\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory) {\n        return Bytes.toNibbles(RLPReader.readBytes(_node.decoded[0]));\n    }\n\n    /**\n     * @notice Gets the value for a node.\n     *\n     * @param _node Node to get a value for.\n     *\n     * @return Node value, as hex bytes.\n     */\n    function _getNodeValue(TrieNode memory _node) private pure returns (bytes memory) {\n        return RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\n    }\n\n    /**\n     * @notice Utility; determines the number of nibbles shared between two nibble arrays.\n     *\n     * @param _a First nibble array.\n     * @param _b Second nibble array.\n     *\n     * @return Number of shared nibbles.\n     */\n    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 shared;\n        uint256 max = (_a.length < _b.length) ? _a.length : _b.length;\n        for (; shared < max && _a[shared] == _b[shared]; ) {\n            unchecked {\n                ++shared;\n            }\n        }\n        return shared;\n    }\n}"
    },
    "@ensdomains/evm-verifier/contracts/SecureMerkleTrie.sol": {
      "content": "// Pulled from https://github.com/ethereum-optimism/optimism/blob/4d13f0afe8869faf7bba45d8339998525ebc5161/packages/contracts-bedrock/contracts/libraries/trie/MerkleTrie.sol\n//   as this is the last version of Optimism's Merkle Trie library that supports nonexistence proofs; support was removed\n//   in the next commit for some version.\n// Copyright 2020-2021 Optimism\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/* Library Imports */\nimport { MerkleTrie } from \"./MerkleTrie.sol\";\n\n/**\n * @title SecureMerkleTrie\n * @notice SecureMerkleTrie is a thin wrapper around the MerkleTrie library that hashes the input\n *         keys. Ethereum's state trie hashes input keys before storing them.\n */\nlibrary SecureMerkleTrie {\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the Merkle trie.\n     *\n     * @param _key   Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\n     *               trees, this proof is executed top-down and consists of a list of RLP-encoded\n     *               nodes that make a path down to the target node.\n     * @param _root  Known root of the Merkle trie. Used to verify that the included proof is\n     *               correctly constructed.\n     *\n     * @return Whether or not the proof is valid.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes[] memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool) {\n        bytes memory key = _getSecureKey(_key);\n        return MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     *\n     * @param _key   Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root  Known root of the Merkle trie.\n     *\n     * @return Whether or not the key exists.\n     * @return Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes[] memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool, bytes memory) {\n        bytes memory key = _getSecureKey(_key);\n        return MerkleTrie.get(key, _proof, _root);\n    }\n\n    /**\n     * @notice Computes the hashed version of the input key.\n     *\n     * @param _key Key to hash.\n     *\n     * @return Hashed version of the key.\n     */\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory) {\n        return abi.encodePacked(keccak256(_key));\n    }\n}"
    },
    "@ensdomains/l1-verifier/contracts/L1Verifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IEVMVerifier } from \"@ensdomains/evm-verifier/contracts/IEVMVerifier.sol\";\nimport { RLPReader } from \"@eth-optimism/contracts-bedrock/src/libraries/rlp/RLPReader.sol\";\nimport { StateProof, EVMProofHelper } from \"@ensdomains/evm-verifier/contracts/EVMProofHelper.sol\";\n\nstruct L1WitnessData {\n    uint256 blockNo;\n    bytes blockHeader;\n}\n\ncontract L1Verifier is IEVMVerifier {\n    error BlockHeaderHashMismatch(uint256 current, uint256 number, bytes32 expected, bytes32 actual);\n\n    string[] _gatewayURLs;\n\n    constructor(string[] memory urls) {\n        _gatewayURLs = urls;\n    }\n\n    function gatewayURLs() external view returns(string[] memory) {\n        return _gatewayURLs;\n    }\n\n    function getStorageValues(address target, bytes32[] memory commands, bytes[] memory constants, bytes memory proof) external view returns(bytes[] memory values) {\n        (L1WitnessData memory l1Data, StateProof memory stateProof) = abi.decode(proof, (L1WitnessData, StateProof));\n        if(keccak256(l1Data.blockHeader) != blockhash(l1Data.blockNo)) {\n            revert BlockHeaderHashMismatch(block.number, l1Data.blockNo, blockhash(l1Data.blockNo), keccak256(l1Data.blockHeader));\n        }\n        RLPReader.RLPItem[] memory headerFields = RLPReader.readList(l1Data.blockHeader);\n        bytes32 stateRoot = bytes32(RLPReader.readBytes(headerFields[3]));\n        return EVMProofHelper.getStorageValues(target, commands, constants, stateRoot, stateProof);\n    }\n}\n"
    },
    "@eth-optimism/contracts-bedrock/src/libraries/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Bytes\n/// @notice Bytes is a library for manipulating byte arrays.\nlibrary Bytes {\n    /// @custom:attribution https://github.com/GNSPS/solidity-bytes-utils\n    /// @notice Slices a byte array with a given starting index and length. Returns a new byte array\n    ///         as opposed to a pointer to the original array. Will throw if trying to slice more\n    ///         bytes than exist in the array.\n    /// @param _bytes Byte array to slice.\n    /// @param _start Starting index of the slice.\n    /// @param _length Length of the slice.\n    /// @return Slice of the input byte array.\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        unchecked {\n            require(_length + 31 >= _length, \"slice_overflow\");\n            require(_start + _length >= _start, \"slice_overflow\");\n            require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n        }\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } { mstore(mc, mload(cc)) }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    /// @notice Slices a byte array with a given starting index up to the end of the original byte\n    ///         array. Returns a new array rathern than a pointer to the original.\n    /// @param _bytes Byte array to slice.\n    /// @param _start Starting index of the slice.\n    /// @return Slice of the input byte array.\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\n        if (_start >= _bytes.length) {\n            return bytes(\"\");\n        }\n        return slice(_bytes, _start, _bytes.length - _start);\n    }\n\n    /// @notice Converts a byte array into a nibble array by splitting each byte into two nibbles.\n    ///         Resulting nibble array will be exactly twice as long as the input byte array.\n    /// @param _bytes Input byte array to convert.\n    /// @return Resulting nibble array.\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n        bytes memory _nibbles;\n        assembly {\n            // Grab a free memory offset for the new array\n            _nibbles := mload(0x40)\n\n            // Load the length of the passed bytes array from memory\n            let bytesLength := mload(_bytes)\n\n            // Calculate the length of the new nibble array\n            // This is the length of the input array times 2\n            let nibblesLength := shl(0x01, bytesLength)\n\n            // Update the free memory pointer to allocate memory for the new array.\n            // To do this, we add the length of the new array + 32 bytes for the array length\n            // rounded up to the nearest 32 byte boundary to the current free memory pointer.\n            mstore(0x40, add(_nibbles, and(not(0x1F), add(nibblesLength, 0x3F))))\n\n            // Store the length of the new array in memory\n            mstore(_nibbles, nibblesLength)\n\n            // Store the memory offset of the _bytes array's contents on the stack\n            let bytesStart := add(_bytes, 0x20)\n\n            // Store the memory offset of the nibbles array's contents on the stack\n            let nibblesStart := add(_nibbles, 0x20)\n\n            // Loop through each byte in the input array\n            for { let i := 0x00 } lt(i, bytesLength) { i := add(i, 0x01) } {\n                // Get the starting offset of the next 2 bytes in the nibbles array\n                let offset := add(nibblesStart, shl(0x01, i))\n                // Load the byte at the current index within the `_bytes` array\n                let b := byte(0x00, mload(add(bytesStart, i)))\n\n                // Pull out the first nibble and store it in the new array\n                mstore8(offset, shr(0x04, b))\n                // Pull out the second nibble and store it in the new array\n                mstore8(add(offset, 0x01), and(b, 0x0F))\n            }\n        }\n        return _nibbles;\n    }\n\n    /// @notice Compares two byte arrays by comparing their keccak256 hashes.\n    /// @param _bytes First byte array to compare.\n    /// @param _other Second byte array to compare.\n    /// @return True if the two byte arrays are equal, false otherwise.\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\n        return keccak256(_bytes) == keccak256(_other);\n    }\n}\n"
    },
    "@eth-optimism/contracts-bedrock/src/libraries/rlp/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\n/// @custom:attribution https://github.com/hamdiallam/Solidity-RLP\n/// @title RLPReader\n/// @notice RLPReader is a library for parsing RLP-encoded byte arrays into Solidity types. Adapted\n///         from Solidity-RLP (https://github.com/hamdiallam/Solidity-RLP) by Hamdi Allam with\n///         various tweaks to improve readability.\nlibrary RLPReader {\n    /// @notice Custom pointer type to avoid confusion between pointers and uint256s.\n    type MemoryPointer is uint256;\n\n    /// @notice RLP item types.\n    /// @custom:value DATA_ITEM Represents an RLP data item (NOT a list).\n    /// @custom:value LIST_ITEM Represents an RLP list item.\n    enum RLPItemType {\n        DATA_ITEM,\n        LIST_ITEM\n    }\n\n    /// @notice Struct representing an RLP item.\n    /// @custom:field length Length of the RLP item.\n    /// @custom:field ptr    Pointer to the RLP item in memory.\n    struct RLPItem {\n        uint256 length;\n        MemoryPointer ptr;\n    }\n\n    /// @notice Max list length that this library will accept.\n    uint256 internal constant MAX_LIST_LENGTH = 32;\n\n    /// @notice Converts bytes to a reference to memory position and length.\n    /// @param _in Input bytes to convert.\n    /// @return out_ Output memory reference.\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory out_) {\n        // Empty arrays are not RLP items.\n        require(_in.length > 0, \"RLPReader: length of an RLP item must be greater than zero to be decodable\");\n\n        MemoryPointer ptr;\n        assembly {\n            ptr := add(_in, 32)\n        }\n\n        out_ = RLPItem({ length: _in.length, ptr: ptr });\n    }\n\n    /// @notice Reads an RLP list value into a list of RLP items.\n    /// @param _in RLP list value.\n    /// @return out_ Decoded RLP list items.\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory out_) {\n        (uint256 listOffset, uint256 listLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.LIST_ITEM, \"RLPReader: decoded item type for list is not a list item\");\n\n        require(listOffset + listLength == _in.length, \"RLPReader: list item has an invalid data remainder\");\n\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n        // writing to the length. Since we can't know the number of RLP items without looping over\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n        // simply set a reasonable maximum list length and decrease the size before we finish.\n        out_ = new RLPItem[](MAX_LIST_LENGTH);\n\n        uint256 itemCount = 0;\n        uint256 offset = listOffset;\n        while (offset < _in.length) {\n            (uint256 itemOffset, uint256 itemLength,) = _decodeLength(\n                RLPItem({ length: _in.length - offset, ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset) })\n            );\n\n            // We don't need to check itemCount < out.length explicitly because Solidity already\n            // handles this check on our behalf, we'd just be wasting gas.\n            out_[itemCount] = RLPItem({\n                length: itemLength + itemOffset,\n                ptr: MemoryPointer.wrap(MemoryPointer.unwrap(_in.ptr) + offset)\n            });\n\n            itemCount += 1;\n            offset += itemOffset + itemLength;\n        }\n\n        // Decrease the array size to match the actual item count.\n        assembly {\n            mstore(out_, itemCount)\n        }\n    }\n\n    /// @notice Reads an RLP list value into a list of RLP items.\n    /// @param _in RLP list value.\n    /// @return out_ Decoded RLP list items.\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory out_) {\n        out_ = readList(toRLPItem(_in));\n    }\n\n    /// @notice Reads an RLP bytes value into bytes.\n    /// @param _in RLP bytes value.\n    /// @return out_ Decoded bytes.\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory out_) {\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.DATA_ITEM, \"RLPReader: decoded item type for bytes is not a data item\");\n\n        require(_in.length == itemOffset + itemLength, \"RLPReader: bytes value contains an invalid remainder\");\n\n        out_ = _copy(_in.ptr, itemOffset, itemLength);\n    }\n\n    /// @notice Reads an RLP bytes value into bytes.\n    /// @param _in RLP bytes value.\n    /// @return out_ Decoded bytes.\n    function readBytes(bytes memory _in) internal pure returns (bytes memory out_) {\n        out_ = readBytes(toRLPItem(_in));\n    }\n\n    /// @notice Reads the raw bytes of an RLP item.\n    /// @param _in RLP item to read.\n    /// @return out_ Raw RLP bytes.\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory out_) {\n        out_ = _copy(_in.ptr, 0, _in.length);\n    }\n\n    /// @notice Decodes the length of an RLP item.\n    /// @param _in RLP item to decode.\n    /// @return offset_ Offset of the encoded data.\n    /// @return length_ Length of the encoded data.\n    /// @return type_ RLP item type (LIST_ITEM or DATA_ITEM).\n    function _decodeLength(RLPItem memory _in)\n        private\n        pure\n        returns (uint256 offset_, uint256 length_, RLPItemType type_)\n    {\n        // Short-circuit if there's nothing to decode, note that we perform this check when\n        // the user creates an RLP item via toRLPItem, but it's always possible for them to bypass\n        // that function and create an RLP item directly. So we need to check this anyway.\n        require(_in.length > 0, \"RLPReader: length of an RLP item must be greater than zero to be decodable\");\n\n        MemoryPointer ptr = _in.ptr;\n        uint256 prefix;\n        assembly {\n            prefix := byte(0, mload(ptr))\n        }\n\n        if (prefix <= 0x7f) {\n            // Single byte.\n            return (0, 1, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xb7) {\n            // Short string.\n\n            // slither-disable-next-line variable-scope\n            uint256 strLen = prefix - 0x80;\n\n            require(\n                _in.length > strLen, \"RLPReader: length of content must be greater than string length (short string)\"\n            );\n\n            bytes1 firstByteOfContent;\n            assembly {\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\n            }\n\n            require(\n                strLen != 1 || firstByteOfContent >= 0x80,\n                \"RLPReader: invalid prefix, single byte < 0x80 are not prefixed (short string)\"\n            );\n\n            return (1, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xbf) {\n            // Long string.\n            uint256 lenOfStrLen = prefix - 0xb7;\n\n            require(\n                _in.length > lenOfStrLen,\n                \"RLPReader: length of content must be > than length of string length (long string)\"\n            );\n\n            bytes1 firstByteOfContent;\n            assembly {\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\n            }\n\n            require(\n                firstByteOfContent != 0x00, \"RLPReader: length of content must not have any leading zeros (long string)\"\n            );\n\n            uint256 strLen;\n            assembly {\n                strLen := shr(sub(256, mul(8, lenOfStrLen)), mload(add(ptr, 1)))\n            }\n\n            require(strLen > 55, \"RLPReader: length of content must be greater than 55 bytes (long string)\");\n\n            require(\n                _in.length > lenOfStrLen + strLen,\n                \"RLPReader: length of content must be greater than total length (long string)\"\n            );\n\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xf7) {\n            // Short list.\n            // slither-disable-next-line variable-scope\n            uint256 listLen = prefix - 0xc0;\n\n            require(_in.length > listLen, \"RLPReader: length of content must be greater than list length (short list)\");\n\n            return (1, listLen, RLPItemType.LIST_ITEM);\n        } else {\n            // Long list.\n            uint256 lenOfListLen = prefix - 0xf7;\n\n            require(\n                _in.length > lenOfListLen,\n                \"RLPReader: length of content must be > than length of list length (long list)\"\n            );\n\n            bytes1 firstByteOfContent;\n            assembly {\n                firstByteOfContent := and(mload(add(ptr, 1)), shl(248, 0xff))\n            }\n\n            require(\n                firstByteOfContent != 0x00, \"RLPReader: length of content must not have any leading zeros (long list)\"\n            );\n\n            uint256 listLen;\n            assembly {\n                listLen := shr(sub(256, mul(8, lenOfListLen)), mload(add(ptr, 1)))\n            }\n\n            require(listLen > 55, \"RLPReader: length of content must be greater than 55 bytes (long list)\");\n\n            require(\n                _in.length > lenOfListLen + listLen,\n                \"RLPReader: length of content must be greater than total length (long list)\"\n            );\n\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n        }\n    }\n\n    /// @notice Copies the bytes from a memory location.\n    /// @param _src    Pointer to the location to read from.\n    /// @param _offset Offset to start reading from.\n    /// @param _length Number of bytes to read.\n    /// @return out_ Copied bytes.\n    function _copy(MemoryPointer _src, uint256 _offset, uint256 _length) private pure returns (bytes memory out_) {\n        out_ = new bytes(_length);\n        if (_length == 0) {\n            return out_;\n        }\n\n        // Mostly based on Solidity's copy_memory_to_memory:\n        // solhint-disable max-line-length\n        // https://github.com/ethereum/solidity/blob/34dd30d71b4da730488be72ff6af7083cf2a91f6/libsolidity/codegen/YulUtilFunctions.cpp#L102-L114\n        uint256 src = MemoryPointer.unwrap(_src) + _offset;\n        assembly {\n            let dest := add(out_, 32)\n            let i := 0\n            for { } lt(i, _length) { i := add(i, 32) } { mstore(add(dest, i), mload(add(src, i))) }\n\n            if gt(i, _length) { mstore(add(dest, _length), 0) }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/deps.sol": {
      "content": "import {L1Verifier} from '@ensdomains/l1-verifier/contracts/L1Verifier.sol';\nimport '@ensdomains/ens-contracts/contracts/reverseRegistrar/L2ReverseRegistrar.sol';\nimport '@ensdomains/ens-contracts/contracts/resolvers/profiles/IVersionableResolver.sol';\n// Storage slot\n// \n//       contract        state_variable    storage_slot \n// \n//  L2ReverseRegistrar       _owner             0       \n//  L2ReverseRegistrar     lastUpdated          1       \n//  L2ReverseRegistrar  versionable_texts       2       \n//  L2ReverseRegistrar  versionable_names       3       \n//  L2ReverseRegistrar   recordVersions         4       \n"
    },
    "contracts/L1ReverseResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {EVMFetcher} from '@ensdomains/evm-verifier/contracts/EVMFetcher.sol';\nimport {EVMFetchTarget} from '@ensdomains/evm-verifier/contracts/EVMFetchTarget.sol';\nimport {IEVMVerifier} from '@ensdomains/evm-verifier/contracts/IEVMVerifier.sol';\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/INameResolver.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\ncontract L1ReverseResolver is EVMFetchTarget, INameResolver, ITextResolver, ERC165 {\n    using EVMFetcher for EVMFetcher.EVMFetchRequest;\n    IEVMVerifier immutable verifier;\n    address immutable target;\n    uint256 constant VERSIONABLE_TEXTS_SLOT = 2;\n    uint256 constant VERSIONABLE_NAME_SLOT = 3;\n    uint256 constant RECORD_VERSIONS_SLOT = 4;\n    \n    constructor(IEVMVerifier _verifier, address _target) {\n        verifier = _verifier;\n        target = _target;\n    }\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n            //  return versionable_names[recordVersions[node]][node];\n    function name(bytes32 node) public view returns (string memory) {\n        EVMFetcher.newFetchRequest(verifier, target)\n            .getStatic(RECORD_VERSIONS_SLOT)\n              .element(node)\n            .getDynamic(VERSIONABLE_NAME_SLOT)\n              .ref(0)\n              .element(node)\n            .fetch(this.nameCallback.selector, ''); // recordVersions\n    }\n\n    function nameCallback(\n        bytes[] memory values,\n        bytes memory\n    ) public pure returns (string memory) {\n        return string(values[1]);\n    }\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(\n        bytes32 node,\n        string calldata key\n    ) public view returns (string memory) {\n        EVMFetcher.newFetchRequest(verifier, target)\n            .getStatic(RECORD_VERSIONS_SLOT)\n              .element(node)\n            .getDynamic(VERSIONABLE_TEXTS_SLOT)\n              .ref(0)\n              .element(node)\n              .element(key)\n            .fetch(this.textCallback.selector, '');\n    }\n\n    function textCallback(\n        bytes[] memory values,\n        bytes memory\n    ) public pure returns (string memory) {\n        return string(values[1]);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public override view returns (bool) {\n        return\n            interfaceId == type(ITextResolver).interfaceId ||\n            interfaceId == type(INameResolver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}